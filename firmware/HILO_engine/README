#-------------------------------------------------------------------------------------------------------------------------------
#                                                     _   _ ___ _     ___  
#                                                    | | | |_ _| |   / _ \ 
#                                                    | |_| || || |  | | | |
#                                                    |  _  || || |__| |_| |
#                                                    |_| |_|___|_____\___/ 
#                                                     Hardware in the loop
#-------------------------------------------------------------------------------------------------------------------------------

1.0 Files
	build                    The rules you need to compile the project
	Core                     The project's source code
	Drivers                  The drivers's source code
	HILO_engine.ioc          
	STM32F031K6TX_FLASH.ld   The linker script generated by CubeMX

2.0 Description
	This component is the one that performs the test, effectively.
	Please, read the ../README and ../HILO_interface/README files

	2.1 Firmware's main steps
	=========================
		0) Hardware initialization
		   Subsystems initialization and I2C channel opening in slave-mode
		
		1) MCU waiting for a command by the HILO_intergace component

		2) Scheduled test running....
		   if HENG_TEST_START command is received and the test has been previousely correctly configured, then the MCU start
		   to performs the test and store the results in the SRAM. While this process is running the MCU can reply to the
		   HENG_TEST_GETSTATUS request with the number of the last executed step. At the end of the test or if an 
		   HENG_TEST_STOP message is received, the MCU returns to wait for new commands
		
		3) Realtime test starting
		   Before to perform the test, the MCU has to get an HENG_RT_SETPINSDIR message to confiure the I/O type of its pins.
		   When the HENG_RT_START command is received, the MCU read data from its input pins and returns the data to the
		   Hilo_interfaces via SPI.
		   The user will be able to change the output pins' values with the HENG_RT_SETPINSVAL command, in "realtime".
		   The HENG_RT_STOP command will force the MCU to returns at the point 1

	2.2 SRAM
	========
	This external memory is used just in the scheduled-test mode. 
	In order to achieve better performance speed, the MCU uses two different memory areas, one just for reading operations the other
	just for data writing, and they are also connected with two different SPI ports.
	For every test's step, MCU will perform the following steps:
		1) The outout pins configuration will be read from the first memory area
		2) HILO's pins will be set properly
		3) The HILO's input pins value will be stored in the second memory area.
		4) The internal counter will be incremented

	Output-pins' configurations storage layout
		+------------------+
		|                  |
		| Number of steps  |
		|      4 bytes     |
		|                  |
		+------------------+
		| XXXXXXXXXXXXXXXX |
		| step 0  (2 bytes)|
		+------------------+
		| XXXXXXXXXXXXXXXX |
		| step 1  (2 bytes)|
		+------------------+
		| XXXXXXXXXXXXXXXX |
		| step 2  (2 bytes)|
		+------------------+
		|//////////////////|
		|//////////////////|

	
	Digital and analog input-pins values storage
		+-------------+--------------+---------------+------------+
		| Inputs pins | Fuses status | Data from A/D |    ???     |
		|   2 bytes   |    2 bytes   |    2 Bytes    |  2 bytes   |
		+----------------------------+---------------+------------+
		| Inputs pins | Fuses status | Data from A/D |    ???     |
		|   2 bytes   |    2 bytes   |    2 Bytes    |  2 bytes   |
		+----------------------------+---------------+------------+
		| Inputs pins | Fuses status | Data from A/D |    ???     |
		|   2 bytes   |    2 bytes   |    2 Bytes    |  2 bytes   |
		+----------------------------+---------------+------------+
		|/////////////////////////////////////////////////////////|
		|/////////////////////////////////////////////////////////|
		|/////////////////////////////////////////////////////////|


3.0 Buiding procedure
	In order to keep track of every change, in the building rules too, I have choice to use the usual Makefile building chain
	insted the ST propritary one. So, in order to build the firmware use make command from the "build" folder inside
